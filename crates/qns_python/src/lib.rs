//! QNS Python Bindings
//!
//! PyO3 bindings for the QNS (Quantum Noise Symbiote) library.
//! Provides noise-aware quantum circuit optimization for NISQ devices.

// Suppress PyO3 pymethods macro warnings (non-local impl definitions)
// These are generated by the PyO3 library and cannot be fixed in user code
#![allow(non_local_definitions)]

use pyo3::exceptions::{PyIndexError, PyValueError};
use pyo3::prelude::*;
use std::collections::HashMap;

use qns_core::types::{
    CircuitGenome, Gate as CoreGate, HardwareProfile as CoreHardwareProfile,
    NoiseVector as CoreNoiseVector, Topology,
};
use qns_rewire::{estimate_fidelity_with_idle_tracking, LiveRewirer, RewireConfig, ScoreConfig};
use qns_simulator::StateVectorSimulator;

// ============================================================================
// Gate Wrapper
// ============================================================================

/// Python wrapper for quantum gates.
#[pyclass(name = "Gate")]
#[derive(Clone)]
pub struct PyGate {
    inner: CoreGate,
}

#[pymethods]
impl PyGate {
    #[staticmethod]
    fn h(qubit: usize) -> Self {
        Self {
            inner: CoreGate::H(qubit),
        }
    }

    #[staticmethod]
    fn x(qubit: usize) -> Self {
        Self {
            inner: CoreGate::X(qubit),
        }
    }

    #[staticmethod]
    fn y(qubit: usize) -> Self {
        Self {
            inner: CoreGate::Y(qubit),
        }
    }

    #[staticmethod]
    fn z(qubit: usize) -> Self {
        Self {
            inner: CoreGate::Z(qubit),
        }
    }

    #[staticmethod]
    fn s(qubit: usize) -> Self {
        Self {
            inner: CoreGate::S(qubit),
        }
    }

    #[staticmethod]
    fn t(qubit: usize) -> Self {
        Self {
            inner: CoreGate::T(qubit),
        }
    }

    #[staticmethod]
    fn rx(qubit: usize, theta: f64) -> Self {
        Self {
            inner: CoreGate::Rx(qubit, theta),
        }
    }

    #[staticmethod]
    fn ry(qubit: usize, theta: f64) -> Self {
        Self {
            inner: CoreGate::Ry(qubit, theta),
        }
    }

    #[staticmethod]
    fn rz(qubit: usize, theta: f64) -> Self {
        Self {
            inner: CoreGate::Rz(qubit, theta),
        }
    }

    #[staticmethod]
    fn cnot(control: usize, target: usize) -> Self {
        Self {
            inner: CoreGate::CNOT(control, target),
        }
    }

    #[staticmethod]
    fn cz(control: usize, target: usize) -> Self {
        Self {
            inner: CoreGate::CZ(control, target),
        }
    }

    #[staticmethod]
    fn swap(qubit1: usize, qubit2: usize) -> Self {
        Self {
            inner: CoreGate::SWAP(qubit1, qubit2),
        }
    }

    #[staticmethod]
    fn measure(qubit: usize) -> Self {
        Self {
            inner: CoreGate::Measure(qubit),
        }
    }

    #[getter]
    fn name(&self) -> String {
        format!("{}", self.inner)
            .split('(')
            .next()
            .unwrap_or("Unknown")
            .to_string()
    }

    #[getter]
    fn qubits(&self) -> Vec<usize> {
        self.inner.qubits()
    }

    #[getter]
    fn is_two_qubit(&self) -> bool {
        self.inner.is_two_qubit()
    }

    #[getter]
    fn angle(&self) -> Option<f64> {
        self.inner.rotation_angle()
    }

    #[getter]
    fn estimated_error(&self) -> f64 {
        self.inner.estimated_error()
    }

    fn commutes_with(&self, other: &PyGate) -> bool {
        self.inner.commutes_with(&other.inner)
    }

    fn __repr__(&self) -> String {
        format!("Gate({})", self.inner)
    }
}

// ============================================================================
// Circuit Wrapper
// ============================================================================

/// Python wrapper for quantum circuits.
#[pyclass(name = "Circuit")]
#[derive(Clone)]
pub struct PyCircuit {
    inner: CircuitGenome,
}

#[pymethods]
impl PyCircuit {
    #[new]
    fn new(num_qubits: usize) -> Self {
        Self {
            inner: CircuitGenome::new(num_qubits),
        }
    }

    #[getter]
    fn num_qubits(&self) -> usize {
        self.inner.num_qubits
    }

    #[getter]
    fn depth(&self) -> usize {
        self.inner.depth()
    }

    #[getter]
    fn two_qubit_count(&self) -> usize {
        self.inner.two_qubit_gate_count()
    }

    #[getter]
    fn gates(&self) -> Vec<PyGate> {
        self.inner
            .gates
            .iter()
            .map(|g| PyGate { inner: g.clone() })
            .collect()
    }

    #[getter]
    fn num_gates(&self) -> usize {
        self.inner.gates.len()
    }

    fn __len__(&self) -> usize {
        self.inner.num_qubits
    }

    fn __getitem__(&self, index: isize) -> PyResult<PyGate> {
        let len = self.inner.gates.len() as isize;
        let idx = if index < 0 { len + index } else { index };
        if idx < 0 || idx >= len {
            return Err(PyIndexError::new_err("Gate index out of range"));
        }
        Ok(PyGate {
            inner: self.inner.gates[idx as usize].clone(),
        })
    }

    fn add_gate(&mut self, gate: &PyGate) -> PyResult<()> {
        self.inner
            .add_gate(gate.inner.clone())
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn h(&mut self, qubit: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::H(qubit))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn x(&mut self, qubit: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::X(qubit))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn y(&mut self, qubit: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::Y(qubit))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn z(&mut self, qubit: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::Z(qubit))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn s(&mut self, qubit: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::S(qubit))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn t(&mut self, qubit: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::T(qubit))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn rx(&mut self, qubit: usize, theta: f64) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::Rx(qubit, theta))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn ry(&mut self, qubit: usize, theta: f64) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::Ry(qubit, theta))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn rz(&mut self, qubit: usize, theta: f64) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::Rz(qubit, theta))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn cnot(&mut self, control: usize, target: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::CNOT(control, target))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn cz(&mut self, control: usize, target: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::CZ(control, target))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn swap(&mut self, qubit1: usize, qubit2: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::SWAP(qubit1, qubit2))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn measure(&mut self, qubit: usize) -> PyResult<()> {
        self.inner
            .add_gate(CoreGate::Measure(qubit))
            .map_err(|e| PyValueError::new_err(e.to_string()))
    }

    fn measure_all(&mut self) -> PyResult<()> {
        for q in 0..self.inner.num_qubits {
            self.inner
                .add_gate(CoreGate::Measure(q))
                .map_err(|e| PyValueError::new_err(e.to_string()))?;
        }
        Ok(())
    }

    fn copy(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }

    fn clear(&mut self) {
        self.inner.clear();
    }

    fn to_json(&self) -> PyResult<String> {
        serde_json::to_string(&self.inner).map_err(|e| PyValueError::new_err(e.to_string()))
    }

    #[staticmethod]
    fn from_json(json_str: &str) -> PyResult<Self> {
        let inner: CircuitGenome =
            serde_json::from_str(json_str).map_err(|e| PyValueError::new_err(e.to_string()))?;
        Ok(Self { inner })
    }

    fn __repr__(&self) -> String {
        format!(
            "Circuit(qubits={}, gates={}, depth={})",
            self.inner.num_qubits,
            self.inner.gates.len(),
            self.inner.depth()
        )
    }
}

// ============================================================================
// NoiseVector Wrapper
// ============================================================================

#[pyclass(name = "NoiseVector")]
#[derive(Clone)]
pub struct PyNoiseVector {
    inner: CoreNoiseVector,
}

#[pymethods]
impl PyNoiseVector {
    #[new]
    #[pyo3(signature = (qubit_id=0, t1=100.0, t2=80.0, gate_error_1q=0.001, gate_error_2q=0.01, readout_error=0.01))]
    fn new(
        qubit_id: usize,
        t1: f64,
        t2: f64,
        gate_error_1q: f64,
        gate_error_2q: f64,
        readout_error: f64,
    ) -> Self {
        Self {
            inner: CoreNoiseVector::comprehensive(
                qubit_id,
                t1,
                t2,
                gate_error_1q,
                gate_error_2q,
                readout_error,
            ),
        }
    }

    #[getter]
    fn qubit_id(&self) -> usize {
        self.inner.qubit_id
    }

    #[getter]
    fn t1(&self) -> f64 {
        self.inner.t1_mean
    }

    #[getter]
    fn t2(&self) -> f64 {
        self.inner.t2_mean
    }

    #[getter]
    fn t_phi(&self) -> Option<f64> {
        self.inner.t_phi()
    }

    #[getter]
    fn gate_error_1q(&self) -> f64 {
        self.inner.gate_error_1q
    }

    #[getter]
    fn gate_error_2q(&self) -> f64 {
        self.inner.gate_error_2q
    }

    #[getter]
    fn readout_error(&self) -> f64 {
        self.inner.readout_error
    }

    #[getter]
    fn t2_t1_ratio(&self) -> f64 {
        self.inner.t2_t1_ratio()
    }

    fn validate(&self) -> PyResult<()> {
        self.inner.validate().map_err(PyValueError::new_err)
    }

    fn estimate_gate_fidelity(&self, gate_time_ns: f64, is_two_qubit: bool) -> f64 {
        self.inner
            .estimate_gate_fidelity(gate_time_ns, is_two_qubit)
    }

    fn __repr__(&self) -> String {
        format!(
            "NoiseVector(qubit={}, T1={:.1}us, T2={:.1}us)",
            self.inner.qubit_id, self.inner.t1_mean, self.inner.t2_mean
        )
    }
}

// ============================================================================
// NoiseModel Wrapper
// ============================================================================

#[pyclass(name = "NoiseModel")]
#[derive(Clone)]
pub struct PyNoiseModel {
    t1: f64,
    t2: f64,
    gate_error_1q: f64,
    gate_error_2q: f64,
    readout_error: f64,
}

#[pymethods]
impl PyNoiseModel {
    #[new]
    #[pyo3(signature = (t1=100.0, t2=80.0, gate_error_1q=0.001, gate_error_2q=0.01, readout_error=0.01))]
    fn new(t1: f64, t2: f64, gate_error_1q: f64, gate_error_2q: f64, readout_error: f64) -> Self {
        Self {
            t1,
            t2,
            gate_error_1q,
            gate_error_2q,
            readout_error,
        }
    }

    #[staticmethod]
    fn ideal() -> Self {
        Self {
            t1: f64::INFINITY,
            t2: f64::INFINITY,
            gate_error_1q: 0.0,
            gate_error_2q: 0.0,
            readout_error: 0.0,
        }
    }

    #[getter]
    fn t1(&self) -> f64 {
        self.t1
    }

    #[getter]
    fn t2(&self) -> f64 {
        self.t2
    }

    #[getter]
    fn gate_error_1q(&self) -> f64 {
        self.gate_error_1q
    }

    #[getter]
    fn gate_error_2q(&self) -> f64 {
        self.gate_error_2q
    }

    #[getter]
    fn readout_error(&self) -> f64 {
        self.readout_error
    }

    fn is_valid(&self) -> bool {
        self.t1 > 0.0
            && self.t2 > 0.0
            && self.t2 <= 2.0 * self.t1  // 물리적 제약: T2 <= 2*T1
            && (0.0..=1.0).contains(&self.gate_error_1q)
            && (0.0..=1.0).contains(&self.gate_error_2q)
            && (0.0..=1.0).contains(&self.readout_error)
    }

    fn to_noise_vector(&self, qubit_id: usize) -> PyNoiseVector {
        PyNoiseVector {
            inner: CoreNoiseVector::comprehensive(
                qubit_id,
                self.t1,
                self.t2,
                self.gate_error_1q,
                self.gate_error_2q,
                self.readout_error,
            ),
        }
    }

    fn __repr__(&self) -> String {
        format!("NoiseModel(T1={:.1}us, T2={:.1}us)", self.t1, self.t2)
    }
}

// ============================================================================
// HardwareProfile Wrapper
// ============================================================================

#[pyclass(name = "HardwareProfile")]
#[derive(Clone)]
pub struct PyHardwareProfile {
    inner: CoreHardwareProfile,
}

#[pymethods]
impl PyHardwareProfile {
    #[staticmethod]
    fn linear(name: &str, num_qubits: usize) -> Self {
        Self {
            inner: CoreHardwareProfile::linear(name, num_qubits),
        }
    }

    #[staticmethod]
    fn ring(name: &str, num_qubits: usize) -> Self {
        Self {
            inner: CoreHardwareProfile::new(name, num_qubits, Topology::Ring),
        }
    }

    #[staticmethod]
    fn fully_connected(name: &str, num_qubits: usize) -> Self {
        Self {
            inner: CoreHardwareProfile::all_to_all(name, num_qubits),
        }
    }

    #[getter]
    fn name(&self) -> String {
        self.inner.name.clone()
    }

    #[getter]
    fn num_qubits(&self) -> usize {
        self.inner.num_qubits
    }

    fn are_connected(&self, q1: usize, q2: usize) -> bool {
        self.inner.are_connected(q1, q2)
    }

    fn neighbors(&self, qubit: usize) -> Vec<usize> {
        self.inner.neighbors(qubit)
    }

    fn coupling_map(&self) -> Vec<(usize, usize)> {
        self.inner
            .couplers
            .iter()
            .map(|c| (c.qubit1, c.qubit2))
            .collect()
    }

    fn set_crosstalk(&mut self, interactions: HashMap<(usize, usize), f64>) {
        for ((q1, q2), strength) in interactions {
            self.inner.crosstalk.set_interaction(q1, q2, strength);
        }
    }

    fn __repr__(&self) -> String {
        format!(
            "HardwareProfile({}, qubits={})",
            self.inner.name, self.inner.num_qubits
        )
    }
}

// ============================================================================
// OptimizationResult Wrapper
// ============================================================================

#[pyclass(name = "OptimizationResult")]
pub struct PyOptimizationResult {
    #[pyo3(get)]
    optimized_circuit: PyCircuit,
    #[pyo3(get)]
    original_score: f64,
    #[pyo3(get)]
    optimized_score: f64,
    #[pyo3(get)]
    variants_explored: usize,
    #[pyo3(get)]
    optimization_time_ms: f64,
    #[pyo3(get)]
    algorithm: String,
}

#[pymethods]
impl PyOptimizationResult {
    #[getter]
    fn score_improvement(&self) -> f64 {
        if self.original_score > 0.0 {
            (self.optimized_score - self.original_score) / self.original_score
        } else {
            0.0
        }
    }

    #[getter]
    fn score_delta(&self) -> f64 {
        self.optimized_score - self.original_score
    }

    fn __repr__(&self) -> String {
        format!(
            "OptimizationResult(improvement={:.2}%)",
            self.score_improvement() * 100.0
        )
    }
}

// ============================================================================
// QnsOptimizer Wrapper
// ============================================================================

#[pyclass(name = "QnsOptimizer")]
pub struct PyQnsOptimizer {
    num_qubits: usize,
    noise_vectors: Vec<CoreNoiseVector>,
    beam_width: usize,
    max_iterations: usize,
    crosstalk_weight: f64,
}

#[pymethods]
impl PyQnsOptimizer {
    #[new]
    #[pyo3(signature = (num_qubits, noise_model=None, beam_width=10, max_iterations=50, crosstalk_weight=0.5))]
    fn new(
        num_qubits: usize,
        noise_model: Option<&PyNoiseModel>,
        beam_width: usize,
        max_iterations: usize,
        crosstalk_weight: f64,
    ) -> Self {
        let noise_vectors = if let Some(nm) = noise_model {
            (0..num_qubits)
                .map(|q| {
                    CoreNoiseVector::comprehensive(
                        q,
                        nm.t1,
                        nm.t2,
                        nm.gate_error_1q,
                        nm.gate_error_2q,
                        nm.readout_error,
                    )
                })
                .collect()
        } else {
            (0..num_qubits)
                .map(|q| CoreNoiseVector::comprehensive(q, 100.0, 80.0, 0.001, 0.01, 0.01))
                .collect()
        };
        Self {
            num_qubits,
            noise_vectors,
            beam_width,
            max_iterations,
            crosstalk_weight,
        }
    }

    #[getter]
    fn num_qubits(&self) -> usize {
        self.num_qubits
    }

    #[getter]
    fn noise_vectors(&self) -> Vec<PyNoiseVector> {
        self.noise_vectors
            .iter()
            .map(|nv| PyNoiseVector { inner: nv.clone() })
            .collect()
    }

    fn set_noise(&mut self, noise: &PyNoiseVector) {
        let qid = noise.inner.qubit_id;
        if qid < self.noise_vectors.len() {
            self.noise_vectors[qid] = noise.inner.clone();
        }
    }

    fn set_noise_model(&mut self, noise_model: &PyNoiseModel) {
        for q in 0..self.num_qubits {
            self.noise_vectors[q] = CoreNoiseVector::comprehensive(
                q,
                noise_model.t1,
                noise_model.t2,
                noise_model.gate_error_1q,
                noise_model.gate_error_2q,
                noise_model.readout_error,
            );
        }
    }

    fn set_beam_params(&mut self, beam_width: usize, max_iterations: usize) {
        self.beam_width = beam_width;
        self.max_iterations = max_iterations;
    }

    #[allow(unused_variables)]
    fn optimize(
        &self,
        circuit: &PyCircuit,
        use_beam_search: Option<bool>,
    ) -> PyResult<PyOptimizationResult> {
        let start = std::time::Instant::now();

        // Get first noise vector for scoring
        let noise = self
            .noise_vectors
            .first()
            .ok_or_else(|| PyValueError::new_err("No noise vectors configured"))?;

        let score_config = ScoreConfig::default();

        // Calculate original score
        let original_score =
            estimate_fidelity_with_idle_tracking(&circuit.inner, noise, &score_config);

        // Create rewirer and optimize
        let config = RewireConfig {
            beam_width: self.beam_width,
            max_variants: self.max_iterations,
            crosstalk_weight: self.crosstalk_weight,
            ..Default::default()
        };

        let mut rewirer = LiveRewirer::with_config(config);
        rewirer
            .load(circuit.inner.clone())
            .map_err(|e| PyValueError::new_err(e.to_string()))?;

        let result = rewirer
            .optimize(noise, self.max_iterations)
            .map_err(|e| PyValueError::new_err(e.to_string()))?;

        let elapsed = start.elapsed().as_secs_f64() * 1000.0;

        Ok(PyOptimizationResult {
            optimized_circuit: PyCircuit {
                inner: result.circuit,
            },
            original_score,
            optimized_score: result.fidelity,
            variants_explored: result.variants_evaluated,
            optimization_time_ms: elapsed,
            algorithm: result.strategy,
        })
    }

    fn score(&self, circuit: &PyCircuit) -> f64 {
        if let Some(noise) = self.noise_vectors.first() {
            let score_config = ScoreConfig::default();
            estimate_fidelity_with_idle_tracking(&circuit.inner, noise, &score_config)
        } else {
            1.0
        }
    }

    fn __repr__(&self) -> String {
        format!(
            "QnsOptimizer(qubits={}, beam_width={})",
            self.num_qubits, self.beam_width
        )
    }
}

// ============================================================================
// ExecutionResult Wrapper
// ============================================================================

#[pyclass(name = "ExecutionResult")]
#[derive(Clone)]
pub struct PyExecutionResult {
    counts: HashMap<String, usize>,
    shots: usize,
    execution_time_ms: f64,
    backend_name: String,
}

#[pymethods]
impl PyExecutionResult {
    #[getter]
    fn counts(&self) -> HashMap<String, usize> {
        self.counts.clone()
    }

    #[getter]
    fn shots(&self) -> usize {
        self.shots
    }

    #[getter]
    fn execution_time_ms(&self) -> f64 {
        self.execution_time_ms
    }

    #[getter]
    fn backend_name(&self) -> String {
        self.backend_name.clone()
    }

    fn probabilities(&self) -> HashMap<String, f64> {
        self.counts
            .iter()
            .map(|(k, &v)| (k.clone(), v as f64 / self.shots as f64))
            .collect()
    }

    fn most_frequent(&self) -> Option<(String, usize)> {
        self.counts
            .iter()
            .max_by_key(|&(_, count)| count)
            .map(|(k, &v)| (k.clone(), v))
    }

    fn get_count(&self, bitstring: &str) -> usize {
        *self.counts.get(bitstring).unwrap_or(&0)
    }

    fn get_probability(&self, bitstring: &str) -> f64 {
        self.get_count(bitstring) as f64 / self.shots as f64
    }

    fn __repr__(&self) -> String {
        format!(
            "ExecutionResult(shots={}, outcomes={})",
            self.shots,
            self.counts.len()
        )
    }
}

// ============================================================================
// CalibrationData Wrapper
// ============================================================================

#[pyclass(name = "CalibrationData")]
#[derive(Clone)]
pub struct PyCalibrationData {
    noise_vectors: Vec<CoreNoiseVector>,
    timestamp: u64,
    source: String,
}

#[pymethods]
impl PyCalibrationData {
    #[getter]
    fn noise_vectors(&self) -> Vec<PyNoiseVector> {
        self.noise_vectors
            .iter()
            .map(|nv| PyNoiseVector { inner: nv.clone() })
            .collect()
    }

    #[getter]
    fn timestamp(&self) -> u64 {
        self.timestamp
    }

    #[getter]
    fn source(&self) -> String {
        self.source.clone()
    }

    #[getter]
    fn num_qubits(&self) -> usize {
        self.noise_vectors.len()
    }

    fn get_qubit(&self, qubit_id: usize) -> PyResult<PyNoiseVector> {
        self.noise_vectors
            .get(qubit_id)
            .map(|nv| PyNoiseVector { inner: nv.clone() })
            .ok_or_else(|| PyValueError::new_err("Invalid qubit ID"))
    }

    fn avg_t1(&self) -> f64 {
        if self.noise_vectors.is_empty() {
            return 0.0;
        }
        self.noise_vectors.iter().map(|nv| nv.t1_mean).sum::<f64>()
            / self.noise_vectors.len() as f64
    }

    fn avg_t2(&self) -> f64 {
        if self.noise_vectors.is_empty() {
            return 0.0;
        }
        self.noise_vectors.iter().map(|nv| nv.t2_mean).sum::<f64>()
            / self.noise_vectors.len() as f64
    }

    fn __repr__(&self) -> String {
        format!(
            "CalibrationData(qubits={}, source={})",
            self.noise_vectors.len(),
            self.source
        )
    }
}

// ============================================================================
// SimulatorBackend Wrapper
// ============================================================================

#[pyclass(name = "SimulatorBackend")]
pub struct PySimulatorBackend {
    name: String,
    num_qubits: usize,
    noise_model: Option<PyNoiseModel>,
}

#[pymethods]
impl PySimulatorBackend {
    #[new]
    #[pyo3(signature = (num_qubits, noise_model=None, name=None))]
    fn new(num_qubits: usize, noise_model: Option<PyNoiseModel>, name: Option<&str>) -> Self {
        Self {
            name: name.unwrap_or("qns_simulator").to_string(),
            num_qubits,
            noise_model,
        }
    }

    #[staticmethod]
    fn ideal(num_qubits: usize) -> Self {
        Self {
            name: "ideal_simulator".to_string(),
            num_qubits,
            noise_model: Some(PyNoiseModel::ideal()),
        }
    }

    #[getter]
    fn name(&self) -> String {
        self.name.clone()
    }

    #[getter]
    fn num_qubits(&self) -> usize {
        self.num_qubits
    }

    #[getter]
    fn max_qubits(&self) -> usize {
        20
    }

    #[getter]
    fn supported_gates(&self) -> Vec<String> {
        vec![
            "h", "x", "y", "z", "s", "t", "rx", "ry", "rz", "cnot", "cz", "swap", "measure",
        ]
        .into_iter()
        .map(String::from)
        .collect()
    }

    #[getter]
    fn supports_mid_circuit_measurement(&self) -> bool {
        true
    }

    #[pyo3(signature = (circuit, shots=1024, _mode="sync"))]
    fn run(&self, circuit: &PyCircuit, shots: usize, _mode: &str) -> PyResult<PyExecutionResult> {
        let start = std::time::Instant::now();

        if circuit.inner.num_qubits > self.num_qubits {
            return Err(PyValueError::new_err(format!(
                "Circuit requires {} qubits, backend has {}",
                circuit.inner.num_qubits, self.num_qubits
            )));
        }

        // Use state vector simulator
        let mut sv = StateVectorSimulator::new(circuit.inner.num_qubits);
        sv.run(&circuit.inner)
            .map_err(|e| PyValueError::new_err(e.to_string()))?;

        let counts = sv
            .measure(shots)
            .map_err(|e| PyValueError::new_err(e.to_string()))?;
        let elapsed = start.elapsed().as_secs_f64() * 1000.0;

        Ok(PyExecutionResult {
            counts,
            shots,
            execution_time_ms: elapsed,
            backend_name: self.name.clone(),
        })
    }

    fn calibration(&self) -> PyCalibrationData {
        let noise_vectors: Vec<CoreNoiseVector> = (0..self.num_qubits)
            .map(|q| {
                if let Some(ref nm) = self.noise_model {
                    CoreNoiseVector::comprehensive(
                        q,
                        nm.t1,
                        nm.t2,
                        nm.gate_error_1q,
                        nm.gate_error_2q,
                        nm.readout_error,
                    )
                } else {
                    CoreNoiseVector::comprehensive(q, 100.0, 80.0, 0.001, 0.01, 0.01)
                }
            })
            .collect();

        PyCalibrationData {
            noise_vectors,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .map(|d| d.as_secs())
                .unwrap_or(0),
            source: "simulator".to_string(),
        }
    }

    fn topology(&self) -> PyHardwareProfile {
        PyHardwareProfile {
            inner: CoreHardwareProfile::linear(&self.name, self.num_qubits),
        }
    }

    fn set_noise(&mut self, noise_model: &PyNoiseModel) {
        self.noise_model = Some(noise_model.clone());
    }

    fn is_available(&self) -> bool {
        true
    }

    fn __repr__(&self) -> String {
        format!(
            "SimulatorBackend({}, qubits={})",
            self.name, self.num_qubits
        )
    }
}

// ============================================================================
// Convert Submodule
// ============================================================================

#[pyclass(name = "convert")]
pub struct PyConvert;

#[pymethods]
impl PyConvert {
    #[staticmethod]
    fn circuit_to_qasm(circuit: &PyCircuit) -> String {
        let mut qasm = String::new();
        qasm.push_str("OPENQASM 2.0;\n");
        qasm.push_str("include \"qelib1.inc\";\n");
        qasm.push_str(&format!("qreg q[{}];\n", circuit.inner.num_qubits));
        qasm.push_str(&format!("creg c[{}];\n", circuit.inner.num_qubits));

        for gate in &circuit.inner.gates {
            let line = match gate {
                CoreGate::H(q) => format!("h q[{}];", q),
                CoreGate::X(q) => format!("x q[{}];", q),
                CoreGate::Y(q) => format!("y q[{}];", q),
                CoreGate::Z(q) => format!("z q[{}];", q),
                CoreGate::S(q) => format!("s q[{}];", q),
                CoreGate::T(q) => format!("t q[{}];", q),
                CoreGate::Rx(q, theta) => format!("rx({}) q[{}];", theta, q),
                CoreGate::Ry(q, theta) => format!("ry({}) q[{}];", theta, q),
                CoreGate::Rz(q, theta) => format!("rz({}) q[{}];", theta, q),
                CoreGate::CNOT(c, t) => format!("cx q[{}],q[{}];", c, t),
                CoreGate::CZ(c, t) => format!("cz q[{}],q[{}];", c, t),
                CoreGate::SWAP(a, b) => format!("swap q[{}],q[{}];", a, b),
                CoreGate::Measure(q) => format!("measure q[{}] -> c[{}];", q, q),
            };
            qasm.push_str(&line);
            qasm.push('\n');
        }
        qasm
    }

    #[staticmethod]
    fn circuit_from_qasm(qasm: &str) -> PyResult<PyCircuit> {
        let mut num_qubits = 0;
        let mut gates = Vec::new();

        for line in qasm.lines() {
            let line = line.trim();
            if line.is_empty()
                || line.starts_with("//")
                || line.starts_with("OPENQASM")
                || line.starts_with("include")
            {
                continue;
            }

            if line.starts_with("qreg") {
                if let Some(start) = line.find('[') {
                    if let Some(end) = line.find(']') {
                        if let Ok(n) = line[start + 1..end].parse::<usize>() {
                            num_qubits = n;
                        }
                    }
                }
            } else if !line.starts_with("creg") {
                if let Some(gate) = parse_gate_line(line) {
                    gates.push(gate);
                }
            }
        }

        if num_qubits == 0 {
            return Err(PyValueError::new_err("No qreg declaration found in QASM"));
        }

        let mut circuit = CircuitGenome::new(num_qubits);
        for gate in gates {
            circuit
                .add_gate(gate)
                .map_err(|e| PyValueError::new_err(e.to_string()))?;
        }
        Ok(PyCircuit { inner: circuit })
    }

    #[staticmethod]
    fn circuit_to_dict(circuit: &PyCircuit) -> PyResult<PyObject> {
        Python::with_gil(|py| {
            let dict = pyo3::types::PyDict::new(py);
            dict.set_item("num_qubits", circuit.inner.num_qubits)?;
            dict.set_item("depth", circuit.inner.depth())?;
            dict.set_item("gate_count", circuit.inner.gates.len())?;

            let mut gates_list = Vec::new();
            for gate in &circuit.inner.gates {
                let mut gate_dict = HashMap::new();
                let (name, qubits, params) = match gate {
                    CoreGate::H(q) => ("H", vec![*q], vec![]),
                    CoreGate::X(q) => ("X", vec![*q], vec![]),
                    CoreGate::Y(q) => ("Y", vec![*q], vec![]),
                    CoreGate::Z(q) => ("Z", vec![*q], vec![]),
                    CoreGate::S(q) => ("S", vec![*q], vec![]),
                    CoreGate::T(q) => ("T", vec![*q], vec![]),
                    CoreGate::Rx(q, theta) => ("RX", vec![*q], vec![*theta]),
                    CoreGate::Ry(q, theta) => ("RY", vec![*q], vec![*theta]),
                    CoreGate::Rz(q, theta) => ("RZ", vec![*q], vec![*theta]),
                    CoreGate::CNOT(c, t) => ("CNOT", vec![*c, *t], vec![]),
                    CoreGate::CZ(c, t) => ("CZ", vec![*c, *t], vec![]),
                    CoreGate::SWAP(a, b) => ("SWAP", vec![*a, *b], vec![]),
                    CoreGate::Measure(q) => ("MEASURE", vec![*q], vec![]),
                };
                gate_dict.insert("name".to_string(), name.to_object(py));
                gate_dict.insert("qubits".to_string(), qubits.to_object(py));
                gate_dict.insert("params".to_string(), params.to_object(py));
                gates_list.push(gate_dict);
            }
            dict.set_item("gates", gates_list)?;
            Ok(dict.into())
        })
    }

    #[staticmethod]
    fn circuit_from_dict(d: &pyo3::types::PyDict) -> PyResult<PyCircuit> {
        let num_qubits: usize = d
            .get_item("num_qubits")?
            .ok_or_else(|| PyValueError::new_err("Missing num_qubits"))?
            .extract()?;

        let mut inner = CircuitGenome::new(num_qubits);

        if let Some(gates_item) = d.get_item("gates")? {
            let gates_list: Vec<HashMap<String, PyObject>> = gates_item.extract()?;

            for gate_dict in gates_list {
                let name: String =
                    Python::with_gil(|py| gate_dict.get("name").unwrap().extract(py))?;
                let qubits: Vec<usize> =
                    Python::with_gil(|py| gate_dict.get("qubits").unwrap().extract(py))?;
                let params: Vec<f64> =
                    Python::with_gil(|py| gate_dict.get("params").unwrap().extract(py))
                        .unwrap_or_default();

                let gate = match name.as_str() {
                    "H" => CoreGate::H(qubits[0]),
                    "X" => CoreGate::X(qubits[0]),
                    "Y" => CoreGate::Y(qubits[0]),
                    "Z" => CoreGate::Z(qubits[0]),
                    "S" => CoreGate::S(qubits[0]),
                    "T" => CoreGate::T(qubits[0]),
                    "RX" => CoreGate::Rx(qubits[0], *params.first().unwrap_or(&0.0)),
                    "RY" => CoreGate::Ry(qubits[0], *params.first().unwrap_or(&0.0)),
                    "RZ" => CoreGate::Rz(qubits[0], *params.first().unwrap_or(&0.0)),
                    "CNOT" => CoreGate::CNOT(qubits[0], qubits[1]),
                    "CZ" => CoreGate::CZ(qubits[0], qubits[1]),
                    "SWAP" => CoreGate::SWAP(qubits[0], qubits[1]),
                    "MEASURE" => CoreGate::Measure(qubits[0]),
                    _ => return Err(PyValueError::new_err(format!("Unknown gate: {}", name))),
                };
                inner
                    .add_gate(gate)
                    .map_err(|e| PyValueError::new_err(e.to_string()))?;
            }
        }

        Ok(PyCircuit { inner })
    }
}

fn parse_gate_line(line: &str) -> Option<CoreGate> {
    let line = line.trim().trim_end_matches(';');

    fn extract_qubit(s: &str) -> Option<usize> {
        let start = s.find('[')?;
        let end = s.find(']')?;
        s[start + 1..end].parse().ok()
    }

    fn extract_angle(s: &str) -> Option<f64> {
        let start = s.find('(')?;
        let end = s.find(')')?;
        s[start + 1..end].parse().ok()
    }

    if line.starts_with("h ") {
        Some(CoreGate::H(extract_qubit(line)?))
    } else if line.starts_with("x ") {
        Some(CoreGate::X(extract_qubit(line)?))
    } else if line.starts_with("y ") {
        Some(CoreGate::Y(extract_qubit(line)?))
    } else if line.starts_with("z ") {
        Some(CoreGate::Z(extract_qubit(line)?))
    } else if line.starts_with("s ") {
        Some(CoreGate::S(extract_qubit(line)?))
    } else if line.starts_with("t ") {
        Some(CoreGate::T(extract_qubit(line)?))
    } else if line.starts_with("rx") {
        Some(CoreGate::Rx(extract_qubit(line)?, extract_angle(line)?))
    } else if line.starts_with("ry") {
        Some(CoreGate::Ry(extract_qubit(line)?, extract_angle(line)?))
    } else if line.starts_with("rz") {
        Some(CoreGate::Rz(extract_qubit(line)?, extract_angle(line)?))
    } else if line.starts_with("cx ") {
        let parts: Vec<&str> = line.split(',').collect();
        if parts.len() != 2 {
            return None;
        }
        Some(CoreGate::CNOT(
            extract_qubit(parts[0])?,
            extract_qubit(parts[1])?,
        ))
    } else if line.starts_with("cz ") {
        let parts: Vec<&str> = line.split(',').collect();
        if parts.len() != 2 {
            return None;
        }
        Some(CoreGate::CZ(
            extract_qubit(parts[0])?,
            extract_qubit(parts[1])?,
        ))
    } else if line.starts_with("swap ") {
        let parts: Vec<&str> = line.split(',').collect();
        if parts.len() != 2 {
            return None;
        }
        Some(CoreGate::SWAP(
            extract_qubit(parts[0])?,
            extract_qubit(parts[1])?,
        ))
    } else if line.starts_with("measure") {
        Some(CoreGate::Measure(extract_qubit(line)?))
    } else {
        None
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

#[pyfunction]
fn estimate_circuit_fidelity(circuit: &PyCircuit, noise: &PyNoiseVector) -> f64 {
    let num_1q = circuit
        .inner
        .gates
        .iter()
        .filter(|g| g.is_single_qubit())
        .count();
    let num_2q = circuit
        .inner
        .gates
        .iter()
        .filter(|g| g.is_two_qubit())
        .count();
    let num_meas = circuit
        .inner
        .gates
        .iter()
        .filter(|g| g.is_measurement())
        .count();
    noise
        .inner
        .estimate_circuit_fidelity(num_1q, num_2q, num_meas, 35.0, 300.0)
}

#[pyfunction]
fn score_circuit(circuit: &PyCircuit, noise: &PyNoiseVector) -> f64 {
    let score_config = ScoreConfig::default();
    estimate_fidelity_with_idle_tracking(&circuit.inner, &noise.inner, &score_config)
}

// ============================================================================
// Qiskit Bridge Functions
// ============================================================================

/// Convert QNS circuit to Qiskit-compatible gate list.
///
/// Returns a list of gate dictionaries for use with qiskit_bridge.py
///
/// Gantree: Task1_3 PyO3Bindings → ExportCircuitConversion
#[pyfunction]
fn convert_circuit_to_qiskit(circuit: &PyCircuit) -> PyResult<Vec<HashMap<String, Py<PyAny>>>> {
    Python::with_gil(|py| {
        let mut gate_list = Vec::new();

        for gate in &circuit.inner.gates {
            let mut gate_dict = HashMap::new();

            // Extract gate name, qubits, and params
            let (name, qubits, params) = match gate {
                CoreGate::H(q) => ("H", vec![*q], vec![]),
                CoreGate::X(q) => ("X", vec![*q], vec![]),
                CoreGate::Y(q) => ("Y", vec![*q], vec![]),
                CoreGate::Z(q) => ("Z", vec![*q], vec![]),
                CoreGate::S(q) => ("S", vec![*q], vec![]),
                CoreGate::T(q) => ("T", vec![*q], vec![]),
                CoreGate::Rx(q, theta) => ("RX", vec![*q], vec![*theta]),
                CoreGate::Ry(q, theta) => ("RY", vec![*q], vec![*theta]),
                CoreGate::Rz(q, theta) => ("RZ", vec![*q], vec![*theta]),
                CoreGate::CNOT(c, t) => ("CNOT", vec![*c, *t], vec![]),
                CoreGate::CZ(c, t) => ("CZ", vec![*c, *t], vec![]),
                CoreGate::SWAP(a, b) => ("SWAP", vec![*a, *b], vec![]),
                _ => {
                    return Err(PyValueError::new_err(format!(
                        "Unsupported gate type for Qiskit conversion: {:?}",
                        gate
                    )))
                },
            };

            gate_dict.insert("name".to_string(), name.to_object(py));
            gate_dict.insert("qubits".to_string(), qubits.to_object(py));
            gate_dict.insert("params".to_string(), params.to_object(py));

            gate_list.push(gate_dict);
        }

        Ok(gate_list)
    })
}

/// Run Qiskit Aer simulation via Python bridge.
///
/// Gantree: Task1_3 PyO3Bindings → ExportSimulationRunner
#[pyfunction]
fn run_aer_simulation(
    py: Python,
    circuit: &PyCircuit,
    shots: usize,
) -> PyResult<HashMap<String, usize>> {
    // Import qiskit_bridge module
    let qiskit_bridge = py.import("qiskit_bridge")?;

    // Get CircuitConverter and AerSimulationRunner classes
    let converter_class = qiskit_bridge.getattr("CircuitConverter")?;
    let runner_class = qiskit_bridge.getattr("AerSimulationRunner")?;

    // Create instances
    let converter = converter_class.call0()?;
    let runner = runner_class.call0()?;

    // Convert circuit to Qiskit format
    let qns_gates = convert_circuit_to_qiskit(circuit)?;
    let num_qubits = circuit.inner.num_qubits;

    let qiskit_circuit = converter.call_method1("qns_to_qiskit", (qns_gates, num_qubits))?;

    // Run simulation
    let counts = runner.call_method1("run", (qiskit_circuit, shots))?;

    // Convert Python dict to Rust HashMap
    let counts_dict: HashMap<String, usize> = counts.extract()?;

    Ok(counts_dict)
}

/// Fetch calibration data from IBM Quantum backend.
///
/// Gantree: Task1_3 PyO3Bindings → ExportCalibrationFetch
#[pyfunction]
fn fetch_ibm_calibration(py: Python, backend_name: &str) -> PyResult<HashMap<String, Py<PyAny>>> {
    // Import qiskit_bridge module
    let qiskit_bridge = py.import("qiskit_bridge")?;

    // Get CalibrationFetcher class
    let fetcher_class = qiskit_bridge.getattr("CalibrationFetcher")?;

    // Create instance
    let fetcher = fetcher_class.call0()?;

    // Connect to backend
    fetcher.call_method1("connect", (backend_name,))?;

    // Fetch properties
    let calibration = fetcher.call_method0("fetch_properties")?;

    // Convert to HashMap
    let cal_dict: HashMap<String, Py<PyAny>> = calibration.extract()?;

    Ok(cal_dict)
}

// ============================================================================
// Module Definition
// ============================================================================

#[pymodule]
fn qns(_py: Python<'_>, m: &PyModule) -> PyResult<()> {
    m.add("__version__", "0.1.0")?;
    m.add("__author__", "QNS Team")?;

    m.add_class::<PyGate>()?;
    m.add_class::<PyCircuit>()?;
    m.add_class::<PyNoiseVector>()?;
    m.add_class::<PyNoiseModel>()?;
    m.add_class::<PyHardwareProfile>()?;
    m.add_class::<PyQnsOptimizer>()?;
    m.add_class::<PyOptimizationResult>()?;
    m.add_class::<PySimulatorBackend>()?;
    m.add_class::<PyExecutionResult>()?;
    m.add_class::<PyCalibrationData>()?;
    m.add_class::<PyConvert>()?;

    m.add_function(wrap_pyfunction!(estimate_circuit_fidelity, m)?)?;
    let _ = m.add_function(wrap_pyfunction!(score_circuit, m)?);

    // Qiskit bridge functions
    m.add_function(wrap_pyfunction!(convert_circuit_to_qiskit, m)?)?;
    m.add_function(wrap_pyfunction!(run_aer_simulation, m)?)?;
    m.add_function(wrap_pyfunction!(fetch_ibm_calibration, m)?)?;

    Ok(())
}
